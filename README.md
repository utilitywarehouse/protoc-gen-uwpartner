# protoc-gen-uwpartner

Generates Go code that makes use of https://github.com/utilitywarehouse/partner-pkg from a proto service definition.
This keeps Partner services free of boilerplate that behave the same.

## Generate

The go code generated by this generator relies on having the go code from `--go_out=plugins=grpc:pb`
also available in the same directory.

1) Create a .proto file that defines a service, for example...

```proto
syntax = "proto3";

package pb;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloResponse) {}
}

message HelloRequest {
    string first_name = 1;
    string last_name = 2;
}

message HelloResponse {
    string message = 1;
}
```

2) Run `protoc --gogo_out=plugins=grpc:pb --uwpartner_out=pb *.proto`

3) You should now have a file `pb/greeter.pb.uwpartner.go`

4) Import **pb** & profit

### Customise

You are able to pass the following options to the protoc generator to customise the generated code.
All these options can be overriden at runtime when creating a service in your go code.

So to override the endpoint & port you can do `protoc --go_out=plugins=grpc:pb --uwpartner_out=endpoint=localhost,port=9000:pb *.proto`.

**namespace**
k8s namespace service runs in (or that you are targetting with the client). Default is "partner".

**name**
name of the service. Default is the name of the service defined in your .proto file.

**endpoint**
Address dialed by the client is formed from namespace & name options. But you many need to override that behaviour.
One example is when developing local, you're going to want to set this to localhost.

**port**
Port that the server listens on & the port the client attempts to connect on.

## Use

**Server:**

- Spins up a GRPC service that registers Greeter
- Bootstraps all necessary interceptors
- Listens for sigterm and gracefully shuts down the server

```golang
package main

import (
	"context"

	"github.com/utilitywarehouse/partner-pkg/service"
	"github.com/utilitywarehouse/partner-some-svc/pb"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	server := pb.NewGreeterService(ctx).Server(new(Greeter))
	defer server.Close()

	if err := server.Run(); err != nil && err != service.ErrSignalClosedServer {
		panic(err)
	}
}

type Greeter struct {
}

func (g *Greeter) SayHello(ctx context.Context, r *pb.HelloRequest) (*pb.HelloResponse, error) {
	return &pb.HelloResponse{Message: "Hello " + r.FirstName}, nil
}
```

**Client:**

- Creates a grpc client, dialed for the GRPC server
- Bootstrap all necessary interceptors. Things like retries are automatically handled.

```golang
    ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	svc := pb.NewGreeterService(ctx)

	greeter, err := svc.Client()
    if err != nil {
        panic(err)
    }
    defer greeter.Close()

    resp, err := greeter.SayHello(context.TODO(), &pb.HelloRequest{FirstName: "Fred", LastName: "Derf"})
    if err != nil {
        panic(err)
    }
    fmt.Printf("response: %+v\n", resp)
```
